<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <title>Zumo Remote</title>
</head>

<body class="bg-dark text-white">
    <div class="container m-0 p-0">
        <div class="row">
            <div class="col-6">
                <div class="row">
                    <div class="col m-2">
                        <br>
                        <div class="container">
                            <div class="row">
                                <div class="col-3">
                                    <button id="connectbutton" class="btn btn-primary w-auto">Connect</button>
                                </div>
                                <div class="col">
                                    <select class="form-select text-white bg-dark" onchange="HandleZumoSelector()" disabled
                                        id="ZumoSelector">
                                        <option selected value="6969">Jerome</option>
                                        <option value="9696">Wayne</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <br>

                        <div class="">
                            <button id="killbutton" onclick="writeToSerial('*|:0*')"
                                class="btn btn-danger disabled mx-3">!!STOP!!</button>
                            <button id="stopbutton" onclick="writeToSerial('*e:0*')"
                                class="btn btn-warning disabled mx-3">Stop
                                Motors</button>
                            <button id="calibratebutton" onclick="writeToSerial('*c:0*')"
                                class="btn btn-secondary disabled mx-3">Calibrate</button>
                        </div>
                        <br>

                        <div class="btn-group" role="group" aria-label="Basic radio toggle button group">
                            <input type="checkbox" class="btn-check disabled" id="ConnectedUSBCheck" autocomplete="off">
                            <label class="btn btn-outline-primary disabled" for="btnradio2">Connection USB</label>
                            <input type="checkbox" class="btn-check disabled" id="ConnectedZumoCheck"
                                autocomplete="off">
                            <label class="btn btn-outline-primary disabled" for="btnradio2">Connection Zumo</label>
                            <input type="checkbox" class="btn-check disabled" id="CTRLR" autocomplete="off">
                            <label class="btn btn-outline-primary disabled" for="btnradio2">Controller</label>
                        </div>
                    </div>
                </div>
                <div class="row">
                    <div class="col m-2">
                        <div class="form-check form-switch">
                            <input class="form-check-input" onclick="writeToSerial('*q:0*')" type="checkbox"
                                id="LineTracking">
                            <label class="form-check-label" for="flexSwitchCheckDefault">Line Tracking</label>
                        </div>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" onclick="writeToSerial('*l:0*')"
                                id="DistanceTracking">
                            <label class="form-check-label" for="flexSwitchCheckDefault">Distance Tracking</label>
                        </div>
                    </div>
                </div>
                Afstandssensoren:
                <div class="row">
                    <div class="col">
                        <div class="bar distancebar">
                            <div id="PSL" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="PSMLL" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="PSML" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="PSMR" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="PSMRR" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="PSR" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                    </div>
                </div>
                <br>
                Lijnsensoren:

                <div class="row">
                    <div class="col">
                        <div class="bar distancebar">
                            <div id="LSL" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="LSML" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="LSM" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="LSMR" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                        <div class="bar distancebar">
                            <div id="LSR" class="innerdistancebar" style="height:0%;"></div>
                        </div>
                    </div>
                </div>


            </div>
            <div class="col-6">
                <div class="col">
                    <div class="mx-4">
                        <pre style="max-height: 600px;overflow-y:hidden;overflow-x:hidden;color:white;width:100%;"
                            id="output"></pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- <pre id="output" style="max-height: 200px;overflow-y:auto;overflow-x:hidden;max-width:400px"></pre> -->
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
        crossorigin="anonymous"></script>
    <script>
        const connectButton = document.getElementById('connectbutton');
        const outputElement = document.getElementById('output');
        var notyf = new Notyf({
            position: {
                x: 'right',
                y: 'top',
            },
        });

        var port, turbo, messagepart = "", lastmessage = "", recieving = false, useKeyboard = true, heartBeat = 0, connectedUSB = false, connectedZumo = false, ATMode;
        //COMM
        connectButton.addEventListener('click', () => {
            connect();
        });

        function HandleUiConnections(type, status, internal = false) {
            if (type == "USB") {
                if ((status != connectedUSB)) {
                    connectedUSB = status;
                    if (status) {
                        notyf.success("Connected USB");
                        document.getElementById("ConnectedUSBCheck").checked = true;
                        document.getElementById("connectbutton").classList.add("disabled");
                        document.getElementById("ZumoSelector").disabled = false;
                    } else {
                        notyf.error("Disconnected USB");
                        document.getElementById("ConnectedUSBCheck").checked = false;
                        document.getElementById("connectbutton").classList.remove("disabled");
                        document.getElementById("ZumoSelector").disabled = true;
                        port = null;
                        HandleUiConnections("Zumo", false, true);
                    }
                }
            } else {
                if ((status != connectedZumo) && (internal || connectedUSB)) {
                    connectedZumo = status;
                    if (status) {
                        notyf.success("Connected Zumo");
                        document.getElementById("ConnectedZumoCheck").checked = true;
                        document.getElementById("stopbutton").classList.remove("disabled");
                        document.getElementById("killbutton").classList.remove("disabled");
                        document.getElementById("calibratebutton").classList.remove("disabled");
                        // writeToSerial("*bt:0*");
                        writeToSerial("*init:0*")
                    } else {
                        notyf.error("Disconnected Zumo");
                        document.getElementById("ConnectedZumoCheck").checked = false;
                        document.getElementById("stopbutton").classList.add("disabled");
                        document.getElementById("killbutton").classList.add("disabled");
                        document.getElementById("calibratebutton").classList.add("disabled");
                    }
                }
            }
        }

        async function connect() {
            if (!navigator.serial) {
                outputElement.textContent = 'Web Serial API not supported.';
                return;
            }
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                HandleUiConnections("USB", true);
                while (port.readable) {
                    try {
                        const reader = port.readable.getReader();
                        const { value, done } = await reader.read();
                        reader.releaseLock();
                        if (done) {
                            break;
                        }
                        var data = new TextDecoder().decode(value)
                        printToConsole(data);
                        HandleSpecialMessages(data);
                    } catch (error) {
                        HandleUiConnections("USB", false);
                        console.error('Error reading from serial port:', error);
                        break;
                    }
                }
                await port.close();
            } catch (error) {
                console.error('Error connecting to serial device:', error);
            }
        }
        function HandleZumoSelector() {
            const dropdown = document.getElementById("ZumoSelector")
            ChangeChannel(dropdown.value);
        }
        async function writeToSerial(data, AT) {
            if (ATMode && !AT) return;
            if (!port) return;
            if (!port.writable) {
                HandleUiConnections("USB", false);
                console.error('Serial port not writable');
                return;
            }
            console.log(data);

            try {
                const writer = port.writable.getWriter();
                const encodedData = new TextEncoder().encode(data);
                await writer.write(encodedData);
                writer.releaseLock();
            } catch (error) {
                console.error('Error writing to serial port:', error);
            }
        }
        //END OF COMM

        //DATA EXTRACTION

        function scale(number, inMin, inMax, outMin, outMax) {//StackOverflow
            return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        function HandleSpecialMessages(msg) {
            if (!msg) return;
            messagepart += msg;
            const regex = /\*(.*?):(.*?)\*/g;
            let match;
            const result = [];

            while ((match = regex.exec(messagepart)) !== null) {
                result.push({ index: match[1], value: match[2] });
                messagepart = messagepart.replace("*" + match[1] + ":" + match[2] + "*", "");
            }
            if (result.length > 0) {
                result.forEach(element => {
                    const index = element.index
                    const value = element.value
                    switch (index) {
                        case "PSL":
                        case "PSMLL":
                        case "PSML":
                        case "PSMR":
                        case "PSMRR":
                        case "PSR":
                            document.getElementById(index).style.height = scale(value, 0, 6, 0, 100) + "%";
                            break;
                        case "LSL":
                        case "LSML":
                        case "LSM":
                        case "LSMR":
                        case "LSR":
                            document.getElementById(index).style.height = scale(value, 0, 1000, 0, 100) + "%";
                            break;
                        case "hb":
                            heartBeat = parseInt(value);
                            break;
                        case "bt":
                            outputElement.textContent = "";
                            break;
                        case "initls":
                            document.getElementById("LineTracking").checked = value == "0" ? false : true;
                            break;
                        case "initps":
                            document.getElementById("DistanceTracking").checked = value == "0" ? false : true;
                            break;
                        default:
                            break;
                    }
                });
            }
            return result;
        }
        //END OF DATA EXTRACTION

        //KEYBOARD FUNCTIONS
        var holdingDown = [];
        function HandleInputCounts(key, updown) {
            if (updown == "keydown") {
                if (!holdingDown.includes(key)) {
                    holdingDown.push(key);
                }
            } else {
                if (holdingDown.includes(key)) {
                    holdingDown = holdingDown.filter(e => e !== key);
                }
            }
        }
        function CheckDoubleInputs(key) {
            return holdingDown.includes(key);
        }
        //END OF KEYBOARD FUNCTIONS


        //WEB CONSOLE
        var ATLogs = "";
        var Channel = 69;
        var ChangingChannel = false;
        async function printToConsole(msg) {
            // console.log(msg)
            outputElement.textContent += msg
            outputElement.scrollTo(0, outputElement.scrollHeight)
            if (ATMode) {
                ATLogs += msg;
                if (ATLogs == "OK\r") {
                    ATLogs = "";
                    if (!ChangingChannel) {
                        await writeToSerial("ATID " + Channel + "\r", true);
                        ChangingChannel = true;
                    } else {
                        notyf.success("Changed Channels");
                        ChangingChannel = false;
                        ATMode = false;
                        await setTimeout(async function () {
                            await writeToSerial("ATCN \r", true)
                        }, 500);
                    }
                }
            }
        }
        //END OF WEB CONSOLE
        async function ChangeChannel(channel) {
            Channel = channel;
            ATMode = true;
            await setTimeout(async function () {
                await writeToSerial("+++", true);
            }, 1000);

        }
        //KEYBOARD
        window.addEventListener('keydown', (event) => {
            if (event.repeat) return;
            // console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                case 'SHIFT':
                    printToConsole("TURBO!!!!\n");
                    turbo = true;
                    break;
                case 'ALT':
                case 'CONTROL':
                case 'TAB':
                case 'F5':
                case 'MEDIAPLAYPAUSE':
                case 'META':
                    //do nothing
                    break;

                default:
                    HandleInputCounts(key, "keydown");
                    writeToSerial(key.toLowerCase());
                    break;
            }
            // console.log("down: " + key)
        });

        window.addEventListener('keyup', (event) => {
            // console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                case 'W':
                case 'A':
                case 'S':
                case 'D':
                    HandleInputCounts(key, "keyup");
                    // if (!CheckDoubleInputs(key)) {
                    //     writeToSerial('*e:0*');
                    // }
                    break;
                case 'SHIFT':
                    printToConsole("No Turbo :(\n");
                    turbo = false;
                    break;

                default:
                    break;
            }
            console.log("up: " + key);
        });
        //KEYBOARD



        //GAMEPAD FUNCTIONS
        var layout =
        {
            0: "padDown",
            1: "padRight",
            2: "padLeft",
            3: "padUp",
            6: "ThrottleLeft",
            7: "ThrottleRight",
            10: "JoyLPress",
            11: "JoyRPress",
            12: "dpadUp",
            13: "dpadDown",
            14: "dpadLeft",
            15: "dpadRight",
            100: "JoyLX",
            101: "JoyLY",
            102: "JoyRX",
            103: "JoyRY",
        };
        var holdingDownController = [];
        var ThrottleMemory = {
            "ThrottleLeft": 0,
            "ThrottleRight": 0,
        };
        var AxisMemory = {
            "JoyLX": 0,
            "JoyLY": 0,
            "JoyRX": 0,
            "JoyRY": 0,
            "ThrottleLeft": 0,
            "ThrottleRight": 0,
        };
        var holdingDownControllerAxes = [];
        async function HandleControllerInputCounts(key, pressed, value = 0) {
            if (pressed) {
                if (!holdingDownController.includes(key)) {
                    if (key != "ThrottleLeft" && key != "ThrottleRight") {
                        holdingDownController.push(key);
                    }
                    // console.log("pressed controller: " + key + value);
                    switch (key) {
                        case 'dpadUp':
                            // await writeToSerial(turbo ? "*w:400*" : '*w:200*');
                            break;
                        case 'dpadDown':
                            // await writeToSerial(turbo ? "*s:400*" : '*s:200*');
                            break;
                        case 'dpadLeft':
                            // await writeToSerial(turbo ? "*a:400*" : '*a:200*');
                            break;
                        case 'dpadRight':
                            // await writeToSerial(turbo ? "*d:400*" : '*d:200*');
                            break;
                        case 'JoyLPress':
                            await writeToSerial("*h:1*");
                            break;
                        case 'padDown':
                            printToConsole("TURBO!!!!\n");
                            turbo = true;
                            break;
                        case 'padRight':
                            await writeToSerial("*|:0*")
                            turbo = true;
                            break;
                        case "ThrottleLeft":
                            AxisMemory[key] = value;
                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);
                            }
                            break;
                        case "ThrottleRight":
                            AxisMemory[key] = value;
                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);
                            }
                        default:
                            break;
                    }
                } else if (key == "ThrottleLeft" || key == "ThrottleRight") {
                    AxisMemory[key] = value;
                    if (Math.abs(AxisMemory[key] - value) >= 0.05) {// don't detect tiny changes, causes too much data to be sent!
                        if (!holdingDownControllerAxes.includes(key)) {
                            holdingDownControllerAxes.push(key);
                        }
                    }
                }
            } else {
                if (holdingDownController.includes(key) || holdingDownControllerAxes.includes(key)) {
                    if (key == "ThrottleLeft" || key == "ThrottleRight") {
                        holdingDownControllerAxes = holdingDownControllerAxes.filter(e => e !== key);
                    } else {
                        holdingDownController = holdingDownController.filter(e => e !== key);
                    }
                    // console.log("released controller: " + key);
                    switch (key) {
                        case 'dpadUp':
                        case 'dpadDown':
                        case 'dpadLeft':
                        case 'dpadRight':
                            // if (!holdingDownControllerAxes.includes("JoyLX")) {
                            //     await writeToSerial('*e:0*');
                            // }
                            break;
                        case 'ThrottleLeft':
                        case 'ThrottleRight':
                            AxisMemory[key] = 0;
                            break;
                        case 'padDown':
                            printToConsole("No Turbo :(\n");
                            turbo = false;
                            break;

                        default:
                            break;
                    }
                }
            }
        }
        var MotorStates = {
            "leftSpeed": 0,
            "rightSpeed": 0,
        }
        async function HandleMotorControl(keyboard = true) {
            var throttle = 0;
            var steer = 0;
            //KEYBOARD INPUT
            if (keyboard && holdingDown.length !== 0) {
                if (holdingDown.includes("W")) {
                    throttle += turbo ? 1 : .5;
                }
                if (holdingDown.includes("A")) {
                    steer += turbo ? 1 : .5;
                }
                if (holdingDown.includes("S")) {
                    throttle -= turbo ? 1 : .5;
                }
                if (holdingDown.includes("D")) {
                    steer -= turbo ? 1 : .5;
                }
            } else if (holdingDownController.length !== 0) {//DPAD INPUT
                if (holdingDownController.includes("dpadDown")) {
                    throttle -= turbo ? 1 : .5;
                }
                if (holdingDownController.includes("dpadUp")) {
                    throttle += turbo ? 1 : .5;
                }
                if (holdingDownController.includes("dpadLeft")) {
                    steer += turbo ? 1 : .5;
                }
                if (holdingDownController.includes("dpadRight")) {
                    steer -= turbo ? 1 : .5;
                }
            } else if (holdingDownControllerAxes.length !== 0) {//JOY INPUT
                throttle = AxisMemory["ThrottleRight"] !== 0 ? AxisMemory["ThrottleRight"] : (AxisMemory["ThrottleLeft"] * -1);
                steer = AxisMemory["JoyLX"] * -1;
            }

            const maxSpeed = 400;
            if (throttle < 0) {
                steer = steer * -1
            }
            // Map throttle to the range [-maxSpeed, maxSpeed]
            let mappedThrottle = scale(throttle, -1, 1, -maxSpeed, maxSpeed);

            // Map steer to the range [-maxSpeed, maxSpeed]
            let mappedSteer = scale(steer, -1, 1, -maxSpeed, maxSpeed);

            // Calculate left and right speeds
            let leftSpeed = mappedThrottle - mappedSteer;
            let rightSpeed = mappedThrottle + mappedSteer;

            // Clamp the speeds to the range [-maxSpeed, maxSpeed]
            leftSpeed = Math.round(Math.min(Math.max(leftSpeed, -maxSpeed), maxSpeed));
            rightSpeed = Math.round(Math.min(Math.max(rightSpeed, -maxSpeed), maxSpeed));

            if (Math.abs(MotorStates["leftSpeed"] - leftSpeed) > 10) {//detect > 10 difference in current speed and target speed, send to arduino
                await writeToSerial("*ls:" + leftSpeed + "*");
            }
            if (Math.abs(MotorStates["rightSpeed"] - rightSpeed) > 10) {//detect > 10 difference in current speed and target speed, send to arduino
                await writeToSerial("*rs:" + rightSpeed + "*");
            }
            // console.log("Left: " + leftSpeed + " Right: " + rightSpeed);
            if (leftSpeed === 0 && rightSpeed === 0 && (MotorStates["rightSpeed"] !== 0 || MotorStates["leftSpeed"] !== 0)) {//one motor currently moving, all motors target 0, stop!
                await writeToSerial("*e:0*");
                // console.log("Stopping");
            }
            MotorStates["leftSpeed"] = leftSpeed;
            MotorStates["rightSpeed"] = rightSpeed;
        }

        async function HandleControllerAxes(key, value) {
            if (Math.abs(AxisMemory[key] - value) >= 0.10) {// don't detect tiny changes, causes too much data to be sent!
                // console.log("Axis Change: " + key + " " + value);
                AxisMemory[key] = value;
                var posval = value <= 0 ? value * -1 : value;
                var scaledValue = Math.round(scale(posval, 0, 1, 0, 400));
                // console.log("Axis Scaled: " + scaledValue);
                switch (key) {
                    case 'JoyLX':
                        if (posval < 0.2) {//deadzone
                            holdingDownControllerAxes = holdingDownControllerAxes.filter(e => e !== key);
                            AxisMemory[key] = 0;
                            break;
                        }
                        if (value > 0 && posval > 0.2) {
                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);
                            }
                        }
                        if (value < 0 && posval > 0.2) {
                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);
                            }
                        }
                        break;
                    default:
                        break;
                }

            }

        }
        //END OF GAMEPAD FUNCTIONS


        //GAMEPAD
        var foundPad = false;
        function HandleGameInputs() {
            var gamepads = navigator.getGamepads();
            gamepads.forEach((controller) => {
                if (controller && controller.id == "Xbox 360 Controller (XInput STANDARD GAMEPAD)") {
                    if (!foundPad) {
                        foundPad = true
                        document.getElementById("CTRLR").checked = true;
                    }
                    controller.buttons.forEach((button, index) => {
                        HandleControllerInputCounts(layout[index], button.pressed, button.value)
                    });
                    controller.axes.forEach((button, index) => {
                        HandleControllerAxes(layout[index + 100], button)
                    });

                }
            });
            HandleMotorControl()
        }
        setInterval(function () {
            HandleGameInputs(useKeyboard);
        }, 100);
        //END OF GAMEPAD

        const HeartBeatTime = 1000;
        async function CheckHeartBeat() {
            await writeToSerial("*hb:0*");
            var OldHeartBeat = heartBeat
            setTimeout(function () {
                if (OldHeartBeat == heartBeat) {
                    HandleUiConnections("Zumo", false);
                } else {
                    HandleUiConnections("Zumo", true);
                }
            }, HeartBeatTime + 500);
        }
        setInterval(function () {
            CheckHeartBeat();
        }, HeartBeatTime);
    </script>

    <style>
        .distancebar {
            margin-left: 5px;
            float: left;
            position: relative;
            background-color: white;
            width: 30px;
            height: 100px;
            border-radius: 8px;
        }

        .innerdistancebar {
            position: absolute;
            bottom: 0px;
            background-color: red;
            width: 100%;
            border-radius: 8px;
        }
    </style>
</body>

</html>