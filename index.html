<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <title>Zumo Remote</title>
</head>

<body class="bg-dark" style="overflow:hidden">
    <div class="">
        <div class="row">
            <div class="col m-2">
                <button id="connect" class="btn btn-primary">Connect</button>
                <button onclick="writeToSerial('*|:0*')" class="btn btn-danger">!!STOP!!</button>
                <button onclick="writeToSerial('*e:0*')" class="btn btn-warning">Stop Motors</button>
                <div class="btn-group" role="group" aria-label="Basic radio toggle button group">
                    <input type="radio" class="btn-check" name="InputType" onchange="SwitchInputs()" value="KB" id="KB" autocomplete="off" checked>
                    <label class="btn btn-outline-primary" for="btnradio1">Keyboard</label>
                  
                    <input type="radio" class="btn-check" name="InputType" onchange="SwitchInputs()" value="CTRLR" id="CTRLR" autocomplete="off">
                    <label class="btn btn-outline-primary" for="btnradio2">Controller</label>
                  </div>
            </div>
        </div>
        <div class="row">
            <div class="col m-2">
                <button onclick="writeToSerial('*c:0*')" class="btn btn-secondary">Calibrate</button>
                <button onclick="writeToSerial('*q:0*')" class="btn btn-secondary">Toggle Line Tracking</button>
                <button onclick="writeToSerial('*l:0*')" class="btn btn-secondary">Toggle Distance Tracking</button>
            </div>
        </div>
        <style>
            .distancebar {
                margin-left: 5px;
                float: left;
                position: relative;
                background-color: white;
                width: 30px;
                height: 100px;
                border-radius: 8px;
            }

            .innerdistancebar {
                position: absolute;
                bottom: 0px;
                background-color: red;
                width: 100%;
                border-radius: 8px;
            }
        </style>
        <div class="row">
            <div class="col">
                <div class="bar distancebar">
                    <div id="PSL" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMLL" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSML" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMR" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMRR" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSR" class="innerdistancebar" style="height:40%;"></div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <div class="mx-4 scrollable-window">
                    <pre style="max-height: 600px;overflow-y:auto;overflow-x:hidden;max-width:400px;color:white;"
                        id="output"></pre>
                </div>
            </div>
        </div>
    </div>
    <!-- <pre id="output" style="max-height: 200px;overflow-y:auto;overflow-x:hidden;max-width:400px"></pre> -->
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
        crossorigin="anonymous"></script>
    <script>
        const connectButton = document.getElementById('connect');
        const outputElement = document.getElementById('output');
        var notyf = new Notyf({
            position: {
                x: 'right',
                y: 'top',
            },
        });

        var port, turbo, messagepart = "", lastmessage = "", recieving = false,useKeyboard = true;
        //COMM
        connectButton.addEventListener('click', () => {
            connect();
        });


        function SwitchInputs() {
            useKeyboard = document.getElementById("KB").checked
        }
        async function connect() {
            if (!navigator.serial) {
                outputElement.textContent = 'Web Serial API not supported.';
                return;
            }
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                notyf.success("Connected!");
                while (port.readable) {
                    try {
                        const reader = port.readable.getReader();
                        const { value, done } = await reader.read();
                        reader.releaseLock();
                        if (done) {
                            break;
                        }
                        var data = new TextDecoder().decode(value)
                        printToConsole(data);
                        HandleSpecialMessages(data);
                    } catch (error) {
                        notyf.error("Disconnected :(");
                        console.error('Error reading from serial port:', error);
                        break;
                    }
                }
                await port.close();
            } catch (error) {
                console.error('Error connecting to serial device:', error);
            }
        }
        async function writeToSerial(data) {
            if (!port) return;
            if (!port.writable) {
                console.error('Serial port not writable');
                return;
            }

            try {
                const writer = port.writable.getWriter();
                const encodedData = new TextEncoder().encode(data);
                await writer.write(encodedData);
                writer.releaseLock();
            } catch (error) {
                console.error('Error writing to serial port:', error);
            }
        }
        //END OF COMM

        //DATA EXTRACTION

        function scale(number, inMin, inMax, outMin, outMax) {//StackOverflow
            return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        function HandleSpecialMessages(msg) {
            if (!msg) return;
            messagepart += msg;
            const regex = /\*(.*?):(.*?)\*/g;
            let match;
            const result = [];

            while ((match = regex.exec(messagepart)) !== null) {
                result.push({ index: match[1], value: match[2] });
                messagepart = messagepart.replace("*" + match[1] + ":" + match[2] + "*", "");
            }
            if (result.length > 0) {
                result.forEach(element => {
                    const index = element.index
                    const value = element.value
                    switch (index) {
                        case "PSL":
                        case "PSMLL":
                        case "PSML":
                        case "PSMR":
                        case "PSMRR":
                        case "PSR":
                            document.getElementById(index).style.height = scale(value, 0, 6, 0, 100) + "%";
                            break;

                        default:
                            break;
                    }
                });
            }
            return result;
        }

        //END OF DATA EXTRACTION

        //KEYBOARD FUNCTIONS
        var holdingDown = [];
        function HandleInputCounts(key, updown) {
            if (updown == "keydown") {
                if (!holdingDown.includes(key)) {
                    holdingDown.push(key);
                }
            } else {
                if (holdingDown.includes(key)) {
                    holdingDown = holdingDown.filter(e => e !== key);
                }
            }
        }
        function CheckDoubleInputs(key) {
            return holdingDown.includes(key);
        }
        //END OF KEYBOARD FUNCTIONS


        //WEB CONSOLE
        function printToConsole(msg) {
            // console.log(msg)
            outputElement.textContent += msg
            outputElement.scrollTo(0, outputElement.scrollHeight)
        }
        //END OF WEB CONSOLE

        //KEYBOARD
        window.addEventListener('keydown', (event) => {
            if (event.repeat) return;
            console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                // case 'W':
                //     HandleInputCounts(key, "keydown");
                //     writeToSerial(turbo ? "*w:400*" : '*w:200*');
                //     break;
                // case 'S':
                //     HandleInputCounts(key, "keydown");
                //     writeToSerial(turbo ? "*s:400*" : '*s:200*');
                //     break;
                // case 'A':
                //     HandleInputCounts(key, "keydown");
                //     writeToSerial(turbo ? "*a:400*" : '*a:200*');
                //     break;
                // case 'D':
                //     HandleInputCounts(key, "keydown");
                //     writeToSerial(turbo ? "*d:400*" : '*d:200*');
                //     break;
                case 'SHIFT':
                    printToConsole("TURBO!!!!\n");
                    turbo = true;
                    break;
                case 'ALT':
                case 'CONTROL':
                case 'TAB':
                case 'F5':
                case 'MEDIAPLAYPAUSE':
                case 'META':
                    //do nothing
                    break;

                default:
                    HandleInputCounts(key, "keydown");
                    writeToSerial(key.toLowerCase());
                    break;
            }
            console.log("down: " + key)
        });

        window.addEventListener('keyup', (event) => {
            console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                case 'W':
                case 'A':
                case 'S':
                case 'D':
                    HandleInputCounts(key, "keyup");
                    if (!CheckDoubleInputs(key)) {
                        writeToSerial('*e:0*');
                    }
                    break;
                case 'SHIFT':
                    printToConsole("No Turbo :(\n");
                    turbo = false;
                    break;

                default:
                    break;
            }
            console.log("up: " + key);
        });
        //KEYBOARD



        //GAMEPAD FUNCTIONS
        var layout =
        {
            0: "padDown",
            1: "padRight",
            2: "padLeft",
            3: "padUp",
            6: "ThrottleLeft",
            7: "ThrottleRight",
            12: "dpadUp",
            13: "dpadDown",
            14: "dpadLeft",
            15: "dpadRight",
            100: "JoyLX",
            101: "JoyLY",
            102: "JoyRX",
            103: "JoyRY",
        };
        var holdingDownController = [];
        var ThrottleMemory = {
            "ThrottleLeft": 0,
            "ThrottleRight": 0,
        };
        var AxisMemory = {
            "JoyLX": 0,
            "JoyLY": 0,
            "JoyRX": 0,
            "JoyRY": 0,
            "ThrottleLeft": 0,
            "ThrottleRight": 0,
        };
        var holdingDownControllerAxes = [];
        async function HandleControllerInputCounts(key, pressed, value = 0) {
            if (pressed) {
                if (!holdingDownController.includes(key)) {
                    holdingDownController.push(key);
                    // console.log("pressed controller: " + key + value);
                    switch (key) {
                        case 'dpadUp':
                            await writeToSerial(turbo ? "*w:400*" : '*w:200*');
                            break;
                        case 'dpadDown':
                            await writeToSerial(turbo ? "*s:400*" : '*s:200*');
                            break;
                        case 'dpadLeft':
                            await writeToSerial(turbo ? "*a:400*" : '*a:200*');
                            break;
                        case 'dpadRight':
                            await writeToSerial(turbo ? "*d:400*" : '*d:200*');
                            break;
                        case 'padDown':
                            printToConsole("TURBO!!!!\n");
                            turbo = true;
                            break;
                        case 'padRight':
                            await writeToSerial("*|:0*")
                            turbo = true;
                            break;
                        default:
                            break;
                    }
                } else if (key == "ThrottleLeft" || key == "ThrottleRight") {
                    AxisMemory[key] = value;
                    if (Math.abs(ThrottleMemory[key] - value) >= 0.05) {// don't detect tiny changes, causes too much data to be sent!
                        ThrottleMemory[key] = value;
                        // console.log("Throttle Change: " + key + " " + value);
                        var scaledValue = Math.round(scale(value, 0, 1, 0, 400));

                        if (!holdingDownControllerAxes.includes(key)) {
                            holdingDownControllerAxes.push(key);
                        } else {
                            // console.log("controlling: " + key);
                        }
                        // switch (key) {
                        //     case 'ThrottleRight':
                        //         if (holdingDownControllerAxes.includes("JoyLX")) {//double input reverse
                        //             // console.log("Double Input!!");
                        //             // await HandleDoubleInput()
                        //             break;
                        //         }
                        //         // await writeToSerial('*w:' + scaledValue + "*");
                        //         break;
                        //     case 'ThrottleLeft':
                        //         if (holdingDownControllerAxes.includes("JoyLX")) {//double input reverse
                        //             // console.log("Double Input!!");
                        //             // await HandleDoubleInput()
                        //             break;
                        //         }
                        //         // await writeToSerial('*s:' + scaledValue + "*");
                        //         break;


                        //     default:
                        //         break;
                        // }

                    }

                }
            } else {
                if (holdingDownController.includes(key)) {
                    if (key == "ThrottleLeft" || key == "ThrottleRight") {
                        holdingDownControllerAxes = holdingDownControllerAxes.filter(e => e !== key);
                    }
                    holdingDownController = holdingDownController.filter(e => e !== key);
                    console.log("released controller: " + key);
                    switch (key) {
                        case 'dpadUp':
                        case 'dpadDown':
                        case 'dpadLeft':
                        case 'dpadRight':
                            if (!holdingDownControllerAxes.includes("JoyLX")) {
                                // await writeToSerial('*e:0*');
                            }
                            break;

                        case 'ThrottleLeft':
                        case 'ThrottleRight':

                            AxisMemory[key] = 0;
                            break;
                        case 'padDown':
                            printToConsole("No Turbo :(\n");
                            turbo = false;
                            break;

                        default:
                            break;
                    }
                }
            }
        }
        var MotorStates = {
            "leftSpeed": 0,
            "rightSpeed": 0,
        }
        async function HandleMotorControl(keyboard = true) {
            var throttle = 0;
            var steer = 0;
            if (keyboard) {
                    if (holdingDown.includes("W")) {
                        throttle += turbo ? 1 : .5;
                    }
                    if (holdingDown.includes("A")) {
                        steer += turbo ? 1 : .5;
                    }
                    if (holdingDown.includes("S")) {
                        throttle -= turbo ? 1 : .5;
                    }
                    if (holdingDown.includes("D")) {
                        steer -= turbo ? 1 : .5;
                    }
            } else {
                throttle = AxisMemory["ThrottleRight"] > 0 ? AxisMemory["ThrottleRight"] : (AxisMemory["ThrottleLeft"] * -1);
                steer = AxisMemory["JoyLX"]*-1;
            }
            const baseSpeed = -400;
            const maxSpeed = 400;

            // Map throttle to the range [baseSpeed, maxSpeed]
            let mappedThrottle = scale(throttle, -1, 1, baseSpeed, maxSpeed);

            // Map steer to the range [-maxSpeed, maxSpeed]
            let mappedSteer = scale(steer, -1, 1, -maxSpeed, maxSpeed);

            // Calculate left and right speeds
            let leftSpeed = mappedThrottle - mappedSteer;
            let rightSpeed = mappedThrottle + mappedSteer;

            // Clamp the speeds to the range [-maxSpeed, maxSpeed]
            leftSpeed = Math.round(Math.min(Math.max(leftSpeed, -maxSpeed), maxSpeed));
            rightSpeed = Math.round(Math.min(Math.max(rightSpeed, -maxSpeed), maxSpeed));

            if (Math.abs(MotorStates["leftSpeed"] - leftSpeed) > 10) {//detect > 10 difference in current speed and target speed, send to arduino
                await writeToSerial("*ls:" + leftSpeed + "*");
            }
            if (Math.abs(MotorStates["rightSpeed"] - rightSpeed) > 10) {//detect > 10 difference in current speed and target speed, send to arduino
                await writeToSerial("*rs:" + rightSpeed + "*");
            }
            console.log("Left: " + leftSpeed + " Right: " + rightSpeed);
            if (leftSpeed === 0 && rightSpeed === 0 && (MotorStates["rightSpeed"] !== 0 || MotorStates["leftSpeed"] !== 0)) {//one motor currently moving, all motors target 0, stop!
                await writeToSerial("*e:0*");
                console.log("Stopping");

            }
            MotorStates["leftSpeed"] = leftSpeed;
            MotorStates["rightSpeed"] = rightSpeed;
        }

        async function HandleDoubleInput() {//returns true if double input handled
            console.log("Active Keys:");
            var Axis1, Axis2 = "";
            // console.log(AxisMemory);
            for (const [key, value] of Object.entries(AxisMemory)) {
                if (value != 0) {
                    Axis1 ? Axis2 = key : Axix1 = key;
                }
            }
            const [leftSpeed, rightSpeed] = calculateSpeeds(AxisMemory["ThrottleRight"] > 0 ? AxisMemory["ThrottleRight"] : (AxisMemory["ThrottleLeft"] * -1), AxisMemory["JoyLX"]);
            await writeToSerial("*ls:" + leftSpeed + "*");
            await writeToSerial("*rs:" + rightSpeed + "*");
        }
        async function HandleControllerAxes(key, value) {
            if (Math.abs(AxisMemory[key] - value) >= 0.10) {// don't detect tiny changes, causes too much data to be sent!
                // console.log("Axis Change: " + key + " " + value);
                AxisMemory[key] = value;
                var posval = value <= 0 ? value * -1 : value;
                var scaledValue = Math.round(scale(posval, 0, 1, 0, 400));
                // console.log("Axis Scaled: " + scaledValue);
                switch (key) {
                    case 'JoyLX':
                        if (posval < 0.2) {//deadzone
                            holdingDownControllerAxes = holdingDownControllerAxes.filter(e => e !== key);
                            AxisMemory[key] = 0;
                            if (!holdingDownControllerAxes.includes("ThrottleLeft") || !holdingDownControllerAxes.includes("ThrottleRight")) {
                                // await writeToSerial("*e:0*");
                            }
                            break;
                        }
                        if (value > 0 && posval > 0.2) {

                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);

                            } else {
                                // console.log("controlling: " + key);
                                if (holdingDownControllerAxes.includes("ThrottleLeft")) {//double input reverse
                                    // console.log("Double Input!!");
                                    // await HandleDoubleInput()
                                    break;
                                }
                                if (holdingDownControllerAxes.includes("ThrottleRight")) {//double input
                                    // console.log("Double Input!!");
                                    // await HandleDoubleInput()
                                    break;
                                }
                            }
                            // writeToSerial('*d:' + scaledValue + "*");
                        }
                        if (value < 0 && posval > 0.2) {

                            if (!holdingDownControllerAxes.includes(key)) {
                                holdingDownControllerAxes.push(key);

                            } else {
                                // console.log("controlling: " + key);
                                if (holdingDownControllerAxes.includes("ThrottleLeft")) {//double input reverse
                                    // console.log("Double Input!!");
                                    // await HandleDoubleInput()
                                    break;
                                }
                                if (holdingDownControllerAxes.includes("ThrottleRight")) {//double input
                                    // console.log("Double Input!!");
                                    // await HandleDoubleInput()
                                    break;
                                }
                            }
                            // await writeToSerial('*a:' + scaledValue + "*");
                        }
                        break;
                    default:
                        break;
                }

            }

        }
        function CheckDoubleControllerInputs(key) {
            return holdingDownController.includes(key);
        }
        //END OF GAMEPAD FUNCTIONS


        //GAMEPAD
        function HandleGameInputs() {
            var gamepads = navigator.getGamepads();
            gamepads.forEach((controller) => {
                if (controller && controller.id == "Xbox 360 Controller (XInput STANDARD GAMEPAD)") {
                    controller.buttons.forEach((button, index) => {
                        HandleControllerInputCounts(layout[index], button.pressed, button.value)
                    });
                    controller.axes.forEach((button, index) => {
                        HandleControllerAxes(layout[index + 100], button)
                    });
                    // console.log(controller);

                }
            });
            HandleMotorControl()
        }
        setInterval(function () {
            HandleGameInputs(useKeyboard);
        }, 100);
        //END OF GAMEPAD









        //graveyard


        function calculateSpeeds(throttle, steer) {//ChatGpt
            const baseSpeed = 30;
            const maxSpeed = 400;

            // Map throttle to the range [baseSpeed, maxSpeed]
            let mappedThrottle = scale(throttle, -1, 1, -400, 400);

            // Map steer to the range [-maxSpeed, maxSpeed]
            let mappedSteer = scale(steer, -1, 1, 400, 400);
            console.log("Throttle: " + mappedThrottle);
            console.log("Steer: " + mappedSteer);
            //steer -400 throttle 400
            //steer 400 throttle 
            let leftSpeed, rightSpeed = 0;
            if (steer > 0) {//steering Right
                leftSpeed = mappedThrottle;
                rightSpeed = mappedThrottle - mappedSteer;
                rightSpeed = Math.min(Math.max(rightSpeed, mappedThrottle < 40 ? 40 : -40), maxSpeed);
            } else {//Steering Left
                leftSpeed = mappedThrottle - mappedSteer;
                rightSpeed = mappedThrottle;
                leftSpeed = Math.min(Math.max(leftSpeed, mappedThrottle < 40 ? 40 : -40), maxSpeed);

            }
            // Calculate left and right speeds
            // let leftSpeed = mappedThrottle - mappedSteer;
            // let rightSpeed = mappedThrottle + mappedSteer;

            // Clamp the speeds to the range [-maxSpeed, maxSpeed]
            // leftSpeed = Math.min(Math.max(leftSpeed, -maxSpeed), maxSpeed);
            // rightSpeed = Math.min(Math.max(rightSpeed, -maxSpeed), maxSpeed);

            return [leftSpeed, rightSpeed];
        }
    </script>

</body>

</html>