<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <title>Zumo Remote</title>
</head>

<body class="bg-dark" style="overflow:hidden">
    <div class="">
        <div class="row">
            <div class="col m-2">
                <button id="connect" class="btn btn-primary">Connect</button>
                <button onclick="writeToSerial('*|:0*')" class="btn btn-danger">!!STOP!!</button>
                <button onclick="writeToSerial('*e:0*')" class="btn btn-warning">Stop Motors</button>
            </div>
        </div>
        <div class="row">
            <div class="col m-2">
                <button onclick="writeToSerial('*c:0*')" class="btn btn-secondary">Calibrate</button>
                <button onclick="writeToSerial('*q:0*')" class="btn btn-secondary">Toggle Line Tracking</button>
                <button onclick="writeToSerial('*l:0*')" class="btn btn-secondary">Toggle Distance Tracking</button>
            </div>
        </div>
        <style>
            .distancebar {
                margin-left: 5px;
                float: left;
                position: relative;
                background-color: white;
                width: 30px;
                height: 100px;
                border-radius: 8px;
            }

            .innerdistancebar {
                position: absolute;
                bottom: 0px;
                background-color: red;
                width: 100%;
                border-radius: 8px;
            }
        </style>
        <div class="row">
            <div class="col">
                <div class="bar distancebar">
                    <div id="PSL" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMLL" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSML" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMR" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSMRR" class="innerdistancebar" style="height:40%;"></div>
                </div>
                <div class="bar distancebar">
                    <div id="PSR" class="innerdistancebar" style="height:40%;"></div>
                </div>
            </div>
        </div>

        <div class="row">
            <div class="col">
                <div class="mx-4 scrollable-window">
                    <pre style="max-height: 600px;overflow-y:auto;overflow-x:hidden;max-width:400px;color:white;"
                        id="output"></pre>
                </div>
            </div>
        </div>
    </div>
    <!-- <pre id="output" style="max-height: 200px;overflow-y:auto;overflow-x:hidden;max-width:400px"></pre> -->
    <script src="https://cdn.jsdelivr.net/npm/notyf@3/notyf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
        crossorigin="anonymous"></script>
    <script>
        const connectButton = document.getElementById('connect');
        const outputElement = document.getElementById('output');
        var notyf = new Notyf({
            position: {
                x: 'right',
                y: 'top',
            },
        });

        var port, turbo, messagepart = "", lastmessage = "", recieving = false;
        //COMM
        connectButton.addEventListener('click', () => {
            connect();
        });

        async function connect() {
            if (!navigator.serial) {
                outputElement.textContent = 'Web Serial API not supported.';
                return;
            }
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                notyf.success("Connected!");
                while (port.readable) {
                    try {
                        const reader = port.readable.getReader();
                        const { value, done } = await reader.read();
                        reader.releaseLock();
                        if (done) {
                            break;
                        }
                        var data = new TextDecoder().decode(value)
                        printToConsole(data);
                        HandleSpecialMessages(data);
                    } catch (error) {
                        notyf.error("Disconnected :(");
                        console.error('Error reading from serial port:', error);
                        break;
                    }
                }
                await port.close();
            } catch (error) {
                console.error('Error connecting to serial device:', error);
            }
        }
        async function writeToSerial(data) {
            if (!port.writable) {
                console.error('Serial port not writable');
                return;
            }

            try {
                const writer = port.writable.getWriter();
                const encodedData = new TextEncoder().encode(data);
                await writer.write(encodedData);
                writer.releaseLock();
            } catch (error) {
                console.error('Error writing to serial port:', error);
            }
        }
        //END OF COMM

        //DATA EXTRACTION

        function scale(number, inMin, inMax, outMin, outMax) {//StackOverflow
            return (number - inMin) * (outMax - outMin) / (inMax - inMin) + outMin;
        }

        function HandleSpecialMessages(msg) {
            if (!msg) return;
            messagepart += msg;
            const regex = /\*(.*?):(.*?)\*/g;
            let match;
            const result = [];

            while ((match = regex.exec(messagepart)) !== null) {
                result.push({ index: match[1], value: match[2] });
                messagepart = messagepart.replace("*" + match[1] + ":" + match[2] + "*", "");
            }
            if (result.length > 0) {
                result.forEach(element => {
                    const index = element.index
                    const value = element.value
                    switch (index) {
                        case "PSL":
                        case "PSMLL":
                        case "PSML":
                        case "PSMR":
                        case "PSMRR":
                        case "PSR":
                            document.getElementById(index).style.height = scale(value, 0, 6, 0, 100) + "%";
                            break;

                        default:
                            break;
                    }
                });
            }
            return result;
        }

        //END OF DATA EXTRACTION

        //KEYBOARD FUNCTIONS
        var holdingDown = [];
        function HandleInputCounts(key, updown) {
            if (updown == "keydown") {
                if (!holdingDown.includes(key)) {
                    holdingDown.push(key);
                }
            } else {
                if (holdingDown.includes(key)) {
                    holdingDown = holdingDown.filter(e => e !== key);
                }
            }
        }
        function CheckDoubleInputs(key) {
            return holdingDown.includes(key);
        }
        //END OF KEYBOARD FUNCTIONS


        //WEB CONSOLE
        function printToConsole(msg) {
            // console.log(msg)
            outputElement.textContent += msg
            outputElement.scrollTo(0, outputElement.scrollHeight)
        }
        //END OF WEB CONSOLE

        //KEYBOARD
        window.addEventListener('keydown', (event) => {
            if (event.repeat) return;
            console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                case 'W':
                    HandleInputCounts(key, "keydown");
                    writeToSerial(turbo ? "*w:400*" : '*w:200*');
                    break;
                case 'S':
                    HandleInputCounts(key, "keydown");
                    writeToSerial(turbo ? "*s:400*" : '*s:200*');
                    break;
                case 'A':
                    HandleInputCounts(key, "keydown");
                    writeToSerial(turbo ? "*a:400*" : '*a:200*');
                    break;
                case 'D':
                    HandleInputCounts(key, "keydown");
                    writeToSerial(turbo ? "*d:400*" : '*d:200*');
                    break;
                case 'SHIFT':
                    printToConsole("TURBO!!!!\n");
                    turbo = true;
                    break;
                case 'ALT':
                case 'CONTROL':
                case 'TAB':
                case 'F5':
                case 'MEDIAPLAYPAUSE':
                case 'META':
                    //do nothing
                    break;

                default:
                    HandleInputCounts(key, "keydown");
                    writeToSerial(key.toLowerCase());
                    break;
            }
            console.log("down: " + key)
        });

        window.addEventListener('keyup', (event) => {
            console.log(holdingDown);
            const key = event.key.toUpperCase();
            switch (key) {
                case 'W':
                case 'A':
                case 'S':
                case 'D':
                    HandleInputCounts(key, "keyup");
                    if (!CheckDoubleInputs(key)) {
                        writeToSerial('*e:0*');
                    }
                    break;
                case 'SHIFT':
                    printToConsole("No Turbo :(\n");
                    turbo = false;
                    break;

                default:
                    break;
            }
            console.log("up: " + key);
        });
        //KEYBOARD



        //GAMEPAD FUNCTIONS
        var layout =
        {
            0: "padDown",
            1: "padRight",
            2: "padLeft",
            3: "padUp",
            6: "ThrottleLeft",
            7: "ThrottleRight",
            12: "dpadUp",
            13: "dpadDown",
            14: "dpadLeft",
            15: "dpadRight",
            100: "JoyLX",
            101: "JoyLY",
            102: "JoyRX",
            103: "JoyRY",
        };
        var holdingDownController = [];
        var ThrottleMemory = {
            "ThrottleLeft": 0,
            "ThrottleRight": 0,
        };
        var AxisMemory = {
            "JoyLX": 0,
            "JoyLY": 0,
            "JoyRX": 0,
            "JoyRY": 0,
        };
        function HandleControllerInputCounts(key, pressed, value = 0) {
            if (pressed) {
                if (!holdingDownController.includes(key)) {
                    holdingDownController.push(key);
                    console.log("pressed controller: " + key + value);
                    switch (key) {
                        case 'dpadUp':
                            writeToSerial(turbo ? "*w:400*" : '*w:200*');
                            break;
                        case 'dpadDown':
                            writeToSerial(turbo ? "*s:400*" : '*s:200*');
                            break;
                        case 'dpadLeft':
                            writeToSerial(turbo ? "*a:400*" : '*a:200*');
                            break;
                        case 'dpadRight':
                            writeToSerial(turbo ? "*d:400*" : '*d:200*');
                            break;
                        case 'padDown':
                            printToConsole("TURBO!!!!\n");
                            turbo = true;
                            break;
                        case 'padRight':
                            writeToSerial("*|:0*")
                            turbo = true;
                            break;
                        default:
                            break;
                    }
                } else if (key == "ThrottleLeft" || key == "ThrottleRight") {
                    if (Math.abs(ThrottleMemory[key] - value) >= 0.05) {// don't detect tiny changes, causes too much data to be sent!
                        ThrottleMemory[key] = value;
                        console.log("Throttle Change: " + key + " " + value);
                        var scaledValue = Math.round(scale(value, 0, 1, 0, 400));
                        switch (key) {
                            case 'ThrottleRight':
                                writeToSerial('*w:' + scaledValue + "*");
                                break;
                            case 'ThrottleLeft':
                                writeToSerial('*s:' + scaledValue + "*");
                                break;


                            default:
                                break;
                        }

                    }

                }
            } else {
                if (holdingDownController.includes(key)) {
                    holdingDownController = holdingDownController.filter(e => e !== key);
                    console.log("released controller: " + key);
                    switch (key) {
                        case 'dpadUp':
                        case 'dpadDown':
                        case 'dpadLeft':
                        case 'dpadRight':
                        case 'ThrottleLeft':
                        case 'ThrottleRight':
                            writeToSerial('*e:0*');
                            break;
                        case 'padDown':
                            printToConsole("No Turbo :(\n");
                            turbo = false;
                            break;

                        default:
                            break;
                    }
                }
            }
        }

        function HandleControllerAxis(key, value) {
            if (Math.abs(AxisMemory[key] - value) >= 0.10) {// don't detect tiny changes, causes too much data to be sent!
                console.log("Axis Change: " + key + " " + value);
                AxisMemory[key] = value;
                var posval = value <= 0 ? value *-1 : value;
                var scaledValue = Math.round(scale(posval, 0, 1, 0, 400));
                console.log("Axis Scaled: " + scaledValue);
                switch (key) {
                    case 'JoyLX':
                        if (posval < 0.2) {//deadzone
                            writeToSerial("*e:0*");
                        }
                        if (value > 0 && posval > 0.2) {
                            writeToSerial('*d:' + scaledValue + "*");
                        }
                        if (value < 0 && posval > 0.2) {
                            writeToSerial('*a:' + scaledValue + "*");
                        }
                        break;
                    default:
                        break;
                }

            }

        }
        function CheckDoubleControllerInputs(key) {
            return holdingDownController.includes(key);
        }
        //END OF GAMEPAD FUNCTIONS


        //GAMEPAD
        function HandleGameInputs() {
            var gamepads = navigator.getGamepads();
            gamepads.forEach((controller) => {
                if (controller && controller.id == "Xbox 360 Controller (XInput STANDARD GAMEPAD)") {
                    controller.buttons.forEach((button, index) => {
                        HandleControllerInputCounts(layout[index], button.pressed, button.value)
                    });
                    controller.axes.forEach((button, index) => {
                        HandleControllerAxis(layout[index + 100], button)
                    });
                    // console.log(controller);

                }
            });
        }
        setInterval(HandleGameInputs, 100);
        //END OF GAMEPAD
    </script>

</body>

</html>